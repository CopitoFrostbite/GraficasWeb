<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nivel Hielo</title>
    <style>
        body { margin: 0; }
    </style>
</head>
<body>

<script type="module">
  import * as THREE from './three.module.js';
  import { OrbitControls } from './OrbitControls.js';
  import { GLTFLoader } from './GLTFLoader.js';
  import { STLLoader } from "./STLLoader.js";
  import Player from './scripts/player.js';
  import PlayerControls from './scripts/playerControls.js';
  import PlayerControls2 from './scripts/playerControls2.js';
  import { checkPlayerCollisions } from './scripts/physics.js';
  const scene = new THREE.Scene();
  const loader = new THREE.TextureLoader();
  
  let rayoModel = null;
  let player = null;
  let player2 = null;
  
  loader.load('./fondo hielo.jpg', function (texture) {
    scene.background = texture;
  });

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 45, 5);

  const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
  scene.add(hemisphereLight);

  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.domElement.tabIndex = '0';
  document.body.appendChild(renderer.domElement);
  renderer.domElement.focus();
  new OrbitControls(camera, renderer.domElement);
  

  const mixers = [];
  const loaderGLTF = new GLTFLoader();
  const clock = new THREE.Clock();
  const textureLoader = new THREE.TextureLoader();
  
  async function init() {
    // Cargar el entorno
    const terreno = await cargarModeloEnPosicion('./modelos/low-poly_ice_world.glb', new THREE.Vector3(0, 0, 0), new THREE.Vector3(1.3, 1.3, 1.3));
    const iceTexture = textureLoader.load('./modelos/iceTex.jpg', function (texture) {
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(1, 1); 

    // Asignar la textura de hielo al material del terreno
    terreno.traverse(function (child) {
        if (child.isMesh) {
            child.material.map = texture;
            child.material.needsUpdate = true;
        }
      });
    });
    // Cargar objetos estáticos 
    const posicionesPinos = [
      new THREE.Vector3(-20, 0, 0),      
      new THREE.Vector3(3, 0.5, -17),
      new THREE.Vector3(20, 0, 4),
      new THREE.Vector3(20, 0, 0),
      new THREE.Vector3(0, 0, -20),
      new THREE.Vector3(0, 0.5, 20),
      
    ];

    /*  // Read
     const starCountRef = ref(db, "jugadores");
      onValue(starCountRef, (snapshot) => {
        const data = snapshot.val();

        Object.entries(data).forEach(([key, value]) => {
          console.log(`${key} ${value.x} ${value.z}`); // "a 5", "b 7", "c 9"
          const jugador = scene.getObjectByName(key);

          // Si no existe el jugador lo agregamos a la escena
          if (!jugador) {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshPhongMaterial();
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(value.x, 0, value.z);
            cube.material.color = new THREE.Color(Math.random() * 0xffffff);
            cube.name = key;
            scene.add(cube);
          } else {
            scene.getObjectByName(key).position.x = value.x;
            scene.getObjectByName(key).position.z = value.z;
          }
        });
      }); */
    
    
    posicionesPinos.forEach(pos => cargarModeloEnPosicion('./modelos/pino.glb', pos, new THREE.Vector3(0.8, 0.8, 0.8)));

    // Cargar objetos animados 
    cargarModeloEnPosicion('./modelos/PolarBear.glb', new THREE.Vector3(15, 1.5, -17), new THREE.Vector3(0.5, 0.5, 0.5));
    cargarRayo(new THREE.Vector3(-13, 2, 0));
    initPlayer(terreno);
    // Iniciar la animación después de cargar todos los modelos
    requestAnimationFrame(animate);
  }
  
  async function initPlayer(terrainMesh) {
    //const playerGeometry = new THREE.BoxGeometry(1, 1, 1); 
    const playerModelData = await cargarModelo('./modelos/StaticZorroR.glb');
    const playerModelData2 = await cargarModelo('./modelos/StaticConejoR.glb');
    //const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xFF5733 });
    //const playerMaterial2 = new THREE.MeshBasicMaterial({ color: 0xAA5733 });
    
    //const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
    //const playerMesh = await cargarModelo(playerModel);
    //  const playerMesh2 = await cargarModelo(playerModel2);
    //const playerMesh2 = new THREE.Mesh(playerGeometry, playerMaterial2);
    //playerMesh.position.set(0, 2, 0); // La posición inicial del jugador en la escena
    //playerMesh2.position.set(2, 2, 0);
    playerModelData.scene.position.set(0, 4, 0);
    playerModelData.scene.scale.set(0.8, 0.8, 0.8)
    playerModelData.scene.rotateY(Math.PI / 2);
    playerModelData2.scene.position.set(2, 4, 0);
    playerModelData2.scene.scale.set(0.8, 0.8, 0.8);
    playerModelData2.scene.rotateY(Math.PI / 2);

    
    renderer.domElement.tabIndex = '0';
    renderer.domElement.focus();


    const playerControls = new PlayerControls(camera, renderer.domElement);
    const playerControls2 = new PlayerControls2(camera, renderer.domElement);
    
   
    
    player = new Player(1,playerModelData,"Zorro", playerControls, scene, terrainMesh);
    player2 = new Player(2,playerModelData2,"Conejo", playerControls2, scene, terrainMesh);
    await cargarAnimaciones('./modelos/AnimacionZorroRun.glb', player.animations.mixer);
    await cargarAnimaciones('./modelos/AnimacionConejoRun.glb', player2.animations.mixer);

    player.animationsMap = {
    'Run': 'Armature|mixamo.com|Layer0',
    
  };
  
  player2.animationsMap = {
    'Run': 'Armature|mixamo.com|Layer0',
    
  };

    scene.add(playerModelData.scene);
    scene.add(playerModelData2.scene);
    
   
    
  }


  async function cargarAnimaciones(url, mixer) {
  try {
    const gltf = await loaderGLTF.loadAsync(url);
    gltf.animations.forEach((clip) => {
     
      const action = mixer.clipAction(clip);
      
      
      action.setLoop(THREE.LoopRepeat);

      
      action.paused = true;

      console.log(`Animación preparada: ${clip.name}`); // Confirma que la animación está lista para ser reproducida
    });
  } catch (error) {
    console.error('Hubo un problema al cargar el archivo GLB:', error);
  }
}
  function cargarModeloEnPosicion(url, posicion, escala) {
    return loaderGLTF.loadAsync(url).then(gltf => {
      const obj = gltf.scene;
      obj.position.copy(posicion);
      obj.scale.copy(escala);
      scene.add(obj);
      if (gltf.animations.length > 0) {
        const mixer = new THREE.AnimationMixer(obj);
        gltf.animations.forEach(clip => {
          mixer.clipAction(clip).play();
        });
        mixers.push(mixer);
      }
      return obj; 
    });
  }

  async function cargarModelo(url) {
   const gltf = await loaderGLTF.loadAsync(url);
   const model = gltf.scene;
   return { scene: gltf.scene, animations: gltf.animations };
  }


  

  function cargarRayo(posicion) {
  loaderGLTF.load('./modelos/rayo.glb', function (model) {
    const obj = model.scene;
    obj.position.copy(posicion);
    obj.scale.set(0.8, 0.5, 0.8);
    scene.add(obj);
    rayoModel = obj; 
  });
  }

  

  let lastFrameTime = Date.now();
  
  function animate() {
    requestAnimationFrame(animate);
    let players = [];
    const now = Date.now();
    const deltaTime = clock.getDelta(); // tiempo en segundos
    

    // Actualizar todos los mixers
    mixers.forEach(mixer => mixer.update(deltaTime));
    if (player) {
        player.update(deltaTime); 
        players.push(player); 
    }
    if (player2) {
        player2.update(deltaTime); 
        players.push(player2);
    }
    checkPlayerCollisions(players);
    if (rayoModel) {
    rayoModel.rotation.y += 0.01; 
  }
    renderer.render(scene, camera);
  }
  init();
  
</script>

</body>
</html>
